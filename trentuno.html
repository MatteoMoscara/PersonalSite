<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trentuno Napoletano - Multiplayer & Vite</title>
    <style>
        :root {
            --table-color: #2e7d32;
            --card-width: 80px;
            --card-height: 125px;
            --bg-dark: #121212;
        }
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg-dark);
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* SCHERMATA INIZIALE */
        #setup-screen, #game-over-screen, #pass-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .hidden { display: none !important; }
        
        h1 { color: #ffd700; text-shadow: 2px 2px 0 #b8860b; font-size: 3rem; margin-bottom: 10px; }
        .setup-box { background: #333; padding: 30px; border-radius: 15px; border: 2px solid #555; max-width: 400px; width: 90%; }
        
        select, input, button {
            padding: 12px;
            margin: 10px 0;
            font-size: 16px;
            width: 100%;
            border-radius: 5px;
            border: none;
        }
        button { background: #d32f2f; color: white; font-weight: bold; cursor: pointer; transition: 0.2s; }
        button:hover { background: #b71c1c; transform: scale(1.02); }
        button:disabled { background: #555; cursor: not-allowed; }

        /* TAVOLO DI GIOCO */
        #game-table {
            display: none;
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 650px;
            background: var(--table-color);
            border: 15px solid #5d4037;
            border-radius: 30px;
            margin-top: 20px;
            box-shadow: inset 0 0 80px rgba(0,0,0,0.6);
        }

        /* GIOCATORI */
        .player-area {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.5s;
        }
        
        /* Posizioni */
        .p-top { top: 10px; left: 50%; transform: translateX(-50%); }
        .p-left { top: 40%; left: 20px; }
        .p-right { top: 40%; right: 20px; }
        .p-bottom { bottom: 20px; left: 50%; transform: translateX(-50%); width: 100%; }

        /* Interfaccia Giocatore */
        .player-info {
            background: rgba(0,0,0,0.7);
            padding: 5px 15px;
            border-radius: 20px;
            margin-bottom: 5px;
            text-align: center;
            border: 2px solid transparent;
        }
        .active-turn .player-info { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; }
        .knocked .player-info { border-color: #ff0000; background: #500; }
        .eliminated { opacity: 0.3; filter: grayscale(100%); }

        .lives { color: #ff4444; font-size: 18px; margin-top: 2px; }
        
        .hand {
            display: flex;
            gap: 5px;
            justify-content: center;
            height: 140px;
            perspective: 1000px;
        }

        /* CARTE */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background-size: cover;
            background-position: center;
            border-radius: 6px;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.4);
            cursor: default;
            transition: transform 0.2s;
            background-color: white;
        }
        .card-back {
            /* Immagine dorso generico */
            background-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Card_back_01.svg/300px-Card_back_01.svg.png');
        }
        
        .playable:hover { transform: translateY(-15px); cursor: pointer; border: 2px solid yellow; }

        /* AREA CENTRALE (Mazzo e Scarti) */
        #center-area {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 40px;
        }
        .pile-zone {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .pile-label { font-size: 12px; margin-top: 5px; text-transform: uppercase; letter-spacing: 1px; color: #fff; text-shadow: 1px 1px 2px black;}

        /* COMANDI */
        #controls {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            justify-content: center;
        }
        .action-btn {
            background: #ffb300;
            color: #000;
            padding: 10px 25px;
            border-radius: 30px;
            font-size: 18px;
            border: 2px solid #fff;
            width: auto;
        }
        .action-btn:disabled { background: #555; color: #888; border-color: #555; }

        #log-area {
            position: absolute;
            bottom: 0; left: 0;
            width: 250px;
            height: 150px;
            background: rgba(0,0,0,0.5);
            font-size: 12px;
            overflow-y: auto;
            padding: 10px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="setup-screen">
        <div class="setup-box">
            <h1>Trentuno üáÆüáπ</h1>
            <p>Carte Napoletane | Vite | No 30¬Ω</p>
            
            <label>Numero Giocatori Umani:</label>
            <select id="num-humans">
                <option value="1">1 (Solo contro Bot)</option>
                <option value="2">2 (Amici)</option>
                <option value="3">3 (Amici)</option>
                <option value="4">4 (Amici)</option>
            </select>

            <label>Difficolt√† Bot:</label>
            <select id="difficulty">
                <option value="easy">Facile (Osteria)</option>
                <option value="hard">Difficile (Campione)</option>
            </select>

            <button onclick="initGame()">DISTRIBUISCI CARTE</button>
        </div>
    </div>

    <div id="pass-screen" class="hidden">
        <div class="setup-box">
            <h2 style="color:white">Tocca a <span id="next-player-name" style="color: #ffd700"></span></h2>
            <p>Passa il dispositivo al giocatore.</p>
            <button onclick="startTurnVisibility()">SONO PRONTO</button>
        </div>
    </div>

    <div id="game-table">
        <div id="log-area"></div>

        <div class="player-area p-top" id="p2"></div>
        <div class="player-area p-left" id="p1"></div>
        <div class="player-area p-right" id="p3"></div>

        <div id="center-area">
            <div class="pile-zone" onclick="playerAction('deck')">
                <div class="card card-back" id="deck-pile"></div>
                <div class="pile-label">Mazzo</div>
            </div>
            <div class="pile-zone" onclick="playerAction('discard')">
                <div class="card" id="discard-pile" style="background-color: transparent; border: 2px dashed rgba(255,255,255,0.3)"></div>
                <div class="pile-label">Scarti</div>
            </div>
        </div>

        <div class="player-area p-bottom" id="p-active">
            <div id="controls">
                <button class="action-btn" id="btn-knock" onclick="playerKnock()">‚úä BUSSA</button>
            </div>
            <div class="hand" id="active-hand"></div>
            <div class="player-info">
                <span id="active-name" style="font-weight:bold; font-size: 1.2em;">TU</span>
                <span id="active-score" style="margin-left:10px; color: yellow;"></span>
                <div class="lives" id="active-lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            </div>
            <div id="instruction" style="text-align: center; margin-top: 10px; text-shadow: 1px 1px black;"></div>
        </div>
    </div>

<script>
/**
 * TRENTUNO - Versione V2
 * Repo Immagini: GitHub (kaizhu256/react-scopa)
 * Mappatura: 1B = Asso Bastoni, 10S = Re Spade
 */

// CONFIGURAZIONE
const CARD_BASE_URL = "https://raw.githubusercontent.com/kaizhu256/react-scopa/master/src/assets/cards/";
const SUITS = ['B', 'C', 'D', 'S']; // Bastoni, Coppe, Denari, Spade
const SUIT_NAMES = {'B': 'Bastoni', 'C': 'Coppe', 'D': 'Denari', 'S': 'Spade'};
const RANKS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; // 8=Fante, 9=Cavallo, 10=Re

// STATO GIOCO
let deck = [];
let discardPile = [];
let players = [];
let currentPlayerIdx = 0;
let knockerIdx = -1;
let gamePhase = 'setup'; // setup, draw, discard, round_end
let difficulty = 'easy';
let roundStarterIdx = 0;

// CLASSI
class Card {
    constructor(suit, rank) {
        this.suit = suit;
        this.rank = rank;
        this.imageUrl = `${CARD_BASE_URL}${rank}${suit}.png`;
        this.value = this.calcValue();
        this.name = `${rank} di ${SUIT_NAMES[suit]}`;
    }

    calcValue() {
        if (this.rank === 1) return 11;
        if (this.rank >= 8) return 10;
        return this.rank;
    }
}

class Player {
    constructor(id, name, isBot) {
        this.id = id;
        this.name = name;
        this.isBot = isBot;
        this.lives = 3;
        this.hand = [];
        this.eliminated = false;
        this.score = 0;
    }

    calcScore() {
        let suitSums = { 'B': 0, 'C': 0, 'D': 0, 'S': 0 };
        this.hand.forEach(c => suitSums[c.suit] += c.value);
        // Regola standard: vince il massimo per seme.
        // NIENTE regola del tris (30.5) come richiesto.
        this.score = Math.max(...Object.values(suitSums));
        return this.score;
    }
}

// INIZIALIZZAZIONE
function initGame() {
    const numHumans = parseInt(document.getElementById('num-humans').value);
    difficulty = document.getElementById('difficulty').value;

    players = [];
    for (let i = 0; i < 4; i++) {
        let isBot = i >= numHumans;
        let name = isBot ? `Bot ${i+1}` : `Giocatore ${i+1}`;
        players.push(new Player(i, name, isBot));
    }

    document.getElementById('setup-screen').classList.add('hidden');
    document.getElementById('game-table').style.display = 'block';
    
    startRound();
}

function startRound() {
    // Reset stato round
    deck = [];
    discardPile = [];
    knockerIdx = -1;
    gamePhase = 'draw';
    
    // Crea mazzo
    for (let s of SUITS) {
        for (let r of RANKS) {
            deck.push(new Card(s, r));
        }
    }
    shuffle(deck);

    // Distribuisci solo ai non eliminati
    let activePlayers = players.filter(p => !p.eliminated);
    if (activePlayers.length < 2) {
        alert(`üèÜ ${activePlayers[0].name} HA VINTO IL TORNEO!`);
        location.reload();
        return;
    }

    // Pulisci mani
    players.forEach(p => p.hand = []);

    // Distribuzione (3 carte)
    for (let i = 0; i < 3; i++) {
        activePlayers.forEach(p => p.hand.push(deck.pop()));
    }

    // Prima carta a terra
    discardPile.push(deck.pop());

    // Imposta il turno (parte chi ha perso o turnazione)
    currentPlayerIdx = roundStarterIdx;
    while(players[currentPlayerIdx].eliminated) {
        currentPlayerIdx = (currentPlayerIdx + 1) % 4;
    }

    updateUI();
    log(`--- NUOVO ROUND ---`);
    checkInstantWin(); // Controllo 31 servito

    handleTurnStart();
}

function handleTurnStart() {
    const p = players[currentPlayerIdx];
    
    if (p.eliminated) {
        endTurn();
        return;
    }

    // Controllo se il giro post-bussata √® finito
    if (knockerIdx !== -1 && currentPlayerIdx === knockerIdx) {
        endRound();
        return;
    }

    if (p.isBot) {
        document.getElementById('pass-screen').classList.add('hidden');
        updateUI(); // Mostra visuale per spettatore
        setTimeout(botPlay, 1000);
    } else {
        // Se √® multiplayer locale, nascondi lo schermo
        const humans = players.filter(pl => !pl.isBot && !pl.eliminated).length;
        if (humans > 1) {
            document.getElementById('next-player-name').innerText = p.name;
            document.getElementById('pass-screen').classList.remove('hidden');
        } else {
            updateUI();
        }
    }
}

function startTurnVisibility() {
    document.getElementById('pass-screen').classList.add('hidden');
    updateUI();
}

// LOGICA AZIONI
function playerAction(source) {
    const p = players[currentPlayerIdx];
    if (p.isBot || gamePhase !== 'draw') return;

    if (source === 'deck') {
        if (deck.length === 0) refillDeck();
        let card = deck.pop();
        p.hand.push(card);
        log(`${p.name} pesca dal mazzo.`);
    } else if (source === 'discard') {
        if (discardPile.length === 0) return;
        let card = discardPile.pop();
        p.hand.push(card);
        log(`${p.name} pesca dagli scarti.`);
    }

    gamePhase = 'discard';
    updateUI();
    
    if (p.calcScore() === 31) {
        alert(`${p.name} HA FATTO 31!`);
        endRound(p.id); // Vince subito il round
    }
}

function playerDiscard(idx) {
    const p = players[currentPlayerIdx];
    if (p.isBot || gamePhase !== 'discard') return;

    let card = p.hand.splice(idx, 1)[0];
    discardPile.push(card);
    log(`${p.name} scarta ${card.name}.`);
    
    if (p.calcScore() === 31) {
        alert(`${p.name} HA FATTO 31!`);
        endRound(p.id);
        return;
    }

    endTurn();
}

function playerKnock() {
    const p = players[currentPlayerIdx];
    if (p.isBot || gamePhase !== 'draw' || knockerIdx !== -1) return;
    
    // Regola minima per bussare
    if (p.calcScore() < 20) {
        alert("Punteggio troppo basso per bussare!");
        return;
    }

    knockerIdx = currentPlayerIdx;
    log(`‚úä ${p.name} HA BUSSATO! Ultimo giro.`);
    endTurn();
}

function endTurn() {
    gamePhase = 'draw';
    do {
        currentPlayerIdx = (currentPlayerIdx + 1) % 4;
    } while (players[currentPlayerIdx].eliminated);

    handleTurnStart();
}

// LOGICA BOT
function botPlay() {
    const bot = players[currentPlayerIdx];
    
    // 1. Bussare?
    if (knockerIdx === -1 && gamePhase === 'draw') {
        let threshold = difficulty === 'hard' ? 26 : 24;
        if (bot.calcScore() >= threshold) {
            knockerIdx = currentPlayerIdx;
            log(`‚úä ${bot.name} bussa!`);
            endTurn();
            return;
        }
    }

    // 2. Pescare
    let topDiscard = discardPile[discardPile.length - 1];
    let tookDiscard = false;

    // Logica semplice: se lo scarto migliora il seme dominante
    let suitCounts = {'B':0, 'C':0, 'D':0, 'S':0};
    bot.hand.forEach(c => suitCounts[c.suit] += c.value);
    let bestSuit = Object.keys(suitCounts).reduce((a,b)=> suitCounts[a]>suitCounts[b]?a:b);

    if (topDiscard && topDiscard.suit === bestSuit && topDiscard.value > 6) {
        discardPile.pop();
        bot.hand.push(topDiscard);
        tookDiscard = true;
        log(`${bot.name} pesca dagli scarti.`);
    } else {
        if (deck.length === 0) refillDeck();
        bot.hand.push(deck.pop());
        log(`${bot.name} pesca dal mazzo.`);
    }

    // 3. Scartare
    // Trova la carta che, tolta, massimizza il punteggio delle restanti 3
    let bestScore = -1;
    let discardIdx = 0;

    for (let i = 0; i < 4; i++) {
        let tempHand = [...bot.hand];
        tempHand.splice(i, 1);
        let s = calcHandScore(tempHand);
        // A parit√† di score, scarta quella di valore pi√π basso per non regalarla
        if (s > bestScore || (s === bestScore && bot.hand[i].value < bot.hand[discardIdx].value)) {
            bestScore = s;
            discardIdx = i;
        }
    }

    let discarded = bot.hand.splice(discardIdx, 1)[0];
    discardPile.push(discarded);
    log(`${bot.name} scarta ${discarded.name}.`);

    if (bestScore === 31) {
        alert(`${bot.name} HA FATTO 31!`);
        endRound(bot.id);
        return;
    }

    endTurn();
}

// FINE ROUND E VITE
function endRound(instantWinnerId = null) {
    let msg = "Fine Round!\n\n";
    let activePlayers = players.filter(p => !p.eliminated);
    
    // Calcola punteggi
    activePlayers.forEach(p => p.calcScore());
    
    // Trova il punteggio peggiore
    let scores = activePlayers.map(p => p.score);
    let minScore = Math.min(...scores);
    
    // Chi perde la vita?
    let losers = [];
    
    if (instantWinnerId !== null) {
        // Se qualcuno ha fatto 31, perdono TUTTI gli altri
        losers = activePlayers.filter(p => p.id !== instantWinnerId);
        msg += `${players[instantWinnerId].name} ha fatto 31!\nGli altri perdono una vita.\n`;
    } else {
        // Altrimenti perde chi ha il punteggio pi√π basso
        losers = activePlayers.filter(p => p.score === minScore);
        if (losers.length > 1) msg += `Pareggio tra ultimi (${minScore} pt).\n`;
        else msg += `Punteggio pi√π basso: ${minScore} (${losers[0].name})\n`;
    }

    // Applica danni
    losers.forEach(p => {
        p.lives--;
        if (p.lives <= 0) {
            p.lives = 0;
            p.eliminated = true;
            msg += `üíÄ ${p.name} √® ELIMINATO!\n`;
        } else {
            msg += `üíî ${p.name} perde una vita (Restanti: ${p.lives})\n`;
        }
    });

    // Aggiorna UI per mostrare tutte le carte
    gamePhase = 'round_end';
    updateUI(true); // showAllHands = true
    
    alert(msg);
    
    // Ruota il mazziere
    roundStarterIdx = (roundStarterIdx + 1) % 4;
    startRound();
}

// UI HELPER
function updateUI(showAllHands = false) {
    // Aggiorna player attivo (quello in basso)
    const activeP = players[currentPlayerIdx];
    const deckDiv = document.getElementById('deck-pile');
    const discardDiv = document.getElementById('discard-pile');

    // Aggiorna Mazzieri/Scarti
    deckDiv.style.display = deck.length > 0 ? 'block' : 'none';
    if (discardPile.length > 0) {
        let top = discardPile[discardPile.length - 1];
        discardDiv.style.backgroundImage = `url('${top.imageUrl}')`;
        discardDiv.style.border = 'none';
    } else {
        discardDiv.style.backgroundImage = 'none';
        discardDiv.style.border = '2px dashed rgba(255,255,255,0.3)';
    }

    // Aggiorna interfaccia per tutti (rotazione visiva)
    // Dobbiamo mappare i giocatori nelle posizioni: Bottom (Active), Left, Top, Right
    // In multiplayer locale, il giocatore di turno √® SEMPRE Bottom
    
    let uiPositions = ['p-bottom', 'p-left', 'p-top', 'p-right'];
    
    // Calcoliamo l'offset per mettere currentPlayerIdx sempre in pos 0 (Bottom)
    let offset = currentPlayerIdx; 

    for (let i = 0; i < 4; i++) {
        // Indice del giocatore reale
        let playerRealIdx = (offset + i) % 4; 
        let p = players[playerRealIdx];
        
        // Se siamo in round_end, non ruotiamo, mostriamo statico? No, meglio mantenere logica rotativa o fissa.
        // Manteniamo logica: Bottom √® chi tocca. Se round end, Bottom √® chi ha finito il turno.
        
        let targetDivId = (i === 0) ? 'p-active' : uiPositions[i].replace('p-', 'p');
        // Hack per i div laterali che hanno ID p1, p2, p3 fissi nel DOM ma ruotiamo il contenuto
        // In realt√† nel DOM ho p-active, p-left (p1), p-top (p2), p-right (p3).
        
        let container = null;
        if (i===0) container = document.getElementById('p-active');
        else if (i===1) container = document.getElementById('p1');
        else if (i===2) container = document.getElementById('p2');
        else if (i===3) container = document.getElementById('p3');

        // Pulisci
        container.innerHTML = '';
        if (p.eliminated) container.classList.add('eliminated');
        else container.classList.remove('eliminated');

        // Costruisci contenuto
        let handHtml = '';
        if (p.eliminated) {
            handHtml = '<span style="color:red">ELIMINATO</span>';
        } else {
            p.hand.forEach((card, cIdx) => {
                // Logica visibilit√†:
                // Se showAllHands = true -> mostra tutto
                // Se i == 0 (Giocatore attivo) -> mostra se √® umano o se √® bot debug
                // Se i != 0 -> mostra coperto
                let visible = showAllHands || (i === 0 && !p.isBot);
                
                // In multiplayer "Passa": se siamo in fase wait non mostriamo nemmeno attivo (gestito da pass-screen)
                
                let bgStyle = visible ? `background-image: url('${card.imageUrl}')` : '';
                let classes = `card ${visible ? '' : 'card-back'}`;
                
                // Cliccabile solo se attivo, umano e fase discard
                if (i === 0 && !p.isBot && gamePhase === 'discard') {
                    classes += ' playable';
                    handHtml += `<div class="${classes}" style="${bgStyle}" onclick="playerDiscard(${cIdx})"></div>`;
                } else {
                    handHtml += `<div class="${classes}" style="${bgStyle}"></div>`;
                }
            });
        }

        // Info box
        let hearts = '‚ù§Ô∏è'.repeat(p.lives) + 'üñ§'.repeat(3 - p.lives);
        let scoreTxt = (showAllHands && !p.eliminated) ? `(${p.calcScore()})` : '';
        let knockStyle = (knockerIdx === p.id) ? 'border: 2px solid red; background: #500;' : '';

        // Template diverso per Active vs Others
        if (i === 0) {
            // Active Player Area
            document.getElementById('active-name').innerText = p.name;
            document.getElementById('active-score').innerText = scoreTxt;
            document.getElementById('active-lives').innerText = hearts;
            document.getElementById('active-hand').innerHTML = handHtml;
            
            // Comandi
            document.getElementById('btn-knock').disabled = (knockerIdx !== -1 || p.isBot || p.calcScore() < 20);
            
            // Istruzioni
            let instr = document.getElementById('instruction');
            if (gamePhase === 'draw') instr.innerText = "Pesca una carta";
            else if (gamePhase === 'discard') instr.innerText = "Scarta una carta";
            else instr.innerText = "Attendi...";
            
        } else {
            // Altri giocatori
            container.innerHTML = `
                <div class="player-info" style="${knockStyle}">
                    <div>${p.name} ${scoreTxt}</div>
                    <div class="lives">${hearts}</div>
                </div>
                <div class="hand" style="transform: scale(0.6);">${handHtml}</div>
            `;
        }
    }
}

function calcHandScore(hand) {
    let suitSums = { 'B': 0, 'C': 0, 'D': 0, 'S': 0 };
    hand.forEach(c => suitSums[c.suit] += c.value);
    return Math.max(...Object.values(suitSums));
}

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function refillDeck() {
    if (discardPile.length <= 1) return;
    let top = discardPile.pop();
    while (discardPile.length > 0) deck.push(discardPile.pop());
    shuffle(deck);
    discardPile.push(top);
    log("Mazzo rimescolato.");
}

function checkInstantWin() {
    players.forEach(p => {
        if (!p.eliminated && p.calcScore() === 31) {
            alert(`${p.name} HA 31 SERVITO!`);
            endRound(p.id);
        }
    });
}

function log(msg) {
    let d = document.getElementById('log-area');
    d.innerHTML += `> ${msg}<br>`;
    d.scrollTop = d.scrollHeight;
}

</script>
</body>
</html>